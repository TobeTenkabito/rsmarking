# RSMarking 平台微服务与代码沙箱扩展指南

## 1. 接入 LLM (如 Gemini) 做智能助手与分析
将 LLM 接入作为微服务，主要负责：**自然语言指令解析**（例如：“帮我提取 2024 年 1 月份云量少于 10% 的影像”）和 **影像解译报告生成**。

### 核心架构
- **Agent Service (Python/FastAPI)**:
    - 职责：作为 LLM 的中转站，维护上下文，并将 LLM 的输出映射为平台 API 调用。
    - 工具调用 (Function Calling): 定义标准的 JSON Schema，让 Gemini 可以触发 `get_raster_list` 或 `start_cloud_extraction`。
- **异步处理流**:
    - 由于 LLM 响应较慢，UI 应采用 WebSocket 或 Server-Sent Events (SSE) 实时显示 LLM 的“思考”过程。

---

## 2. 自定义代码处理（Python 3 & Java 21）
支持用户上传代码处理遥感数据是最高级的扩展功能，这需要构建 **分布式任务调度** 和 **安全沙箱环境**。

### A. 核心架构：任务中心方案
- **Task Orchestrator (任务编排器)**:
    - 接收用户代码、环境要求（Py3/Java21）和目标数据。
    - 将任务压入消息队列 (RabbitMQ/Redis)。
- **Polyglot Workers (多语言执行节点)**:
    - 运行在不同的 Docker 容器或 K8s Pod 中。
    - **Python Worker**: 预装 `GDAL`, `Rasterio`, `NumPy`, `PyTorch`。
    - **Java Worker**: 预装 `GeoTools`, `JTS` 等地理空间库。

### B. 安全沙箱 (Security Sandbox) - 关键点
直接运行用户代码极其危险，必须通过以下方式隔离：
1.  **容器化隔离**: 每个任务启动一个单次使用的 Docker 容器（Sidecar 模式），限制 CPU 和内存。
2.  **资源限额 (Quotas)**: 限制容器的运行时长（如 5 分钟）、网络访问（禁止访问内网数据库）和磁盘 IO。
3.  **gVisor/Kata Containers**: 如果安全性要求极高，使用 gVisor 作为 Docker 的运行运行时，提供更强的内核级隔离。

---

## 3. 技术栈建议

### 微服务治理
- **API Gateway (Nginx/Kong)**: 统一入口，处理 JWT 鉴权。
- **Storage Service (MinIO/S3)**: 用户代码生成的中间 TIF、Mask 结果统一存入对象存储，并通过 `index_id` 关联。

### 运行时环境
| 语言 | 运行时容器 | 推荐库 |
| :--- | :--- | :--- |
| **Python 3** | Docker (python:3.10-slim) | Rasterio, GDAL, WhiteboxTools, PySTAC |
| **Java 21** | Docker (eclipse-temurin:21) | GeoTools, Apache SIS, JAI (Java Advanced Imaging) |

---

## 4. 逻辑扩展流示例：用户提交 Python 脚本提取水体

1.  **Frontend**: 用户在代码编辑器编写 Python 脚本，点击“执行”。
2.  **API Gateway**: 验证权限，将脚本存入 MinIO。
3.  **Task Service**:
    - 创建任务记录，状态为 `PENDING`。
    - 发送消息：`{ "task_id": "T1", "lang": "python", "script_url": "...", "data_id": "3444..." }`。
4.  **Worker Cluster**:
    - Python Worker 抢占消息，拉取脚本和影像。
    - 在独立 Docker 内运行：`python user_script.py --input input.tif --output result.tif`。
5.  **Result Handler**:
    - 将 `result.tif` 上传，生成新的瓦片服务。
    - 回调通知前端：图层已就绪，自动在 `map.js` 中 `addGeoRasterLayer`。

---

## 5. 理论上的 MapEngine 修改
为了配合这类扩展，你的 `MapEngine` 需要支持：
- **Layer Grouping**: 将用户生成的 Mask 图层与原始图层进行组管理。
- **Real-time Status Overlay**: 在图层渲染未完成时，在地图上显示“处理中...”的 Canvas 覆盖层。
- **Opacity Mixing**: 支持用户在前端动态调整自定义处理结果（如水体层）的透明度。